## Лекция по теме "08.05 Тестирование Roles"


### Тестирование Roles    00:09:00
Алексей
Метляков
1Алексей Метляков
DevOps Engineer
OpenWay
Алексей Метляков

### 2План занятия
1. Как тестировать Role?
2. Molecule
3. Tox
4. Итоги
5. Домашнее задание

### 3Как тестировать Role?    00:09:47
В данном виде тестирование Role превращается в достаточно
сложную задачу, так как нужно:
- Провести проверку синтаксиса;
- Подготовить тестовое окружение;
- Провести проверку на работоспособность;
- Провести проверку на идемпотентность;
- Исправить ошибки на каждом из этих этапов и повторять весь
сценарий, пока не будет получен положительный результат.

### 4Molecule   00:12:39
Данный фреймворк позволяет избавить нас от рутины и заниматься
только созданием и исправлением ошибок. Он умеет:
- Создавать новые roles;
- Создавать scenarios тестирования;
- Тестировать roles против разного окружения;
- Поддерживает docker, podman, delegated как драйверы подключений.
Официальная документация [тут](https://molecule.readthedocs.io/en/stable-1.18/index.html#)

### 5Как создать Role?      00:16:05
- Создать стандартную структуру директорий и файлов при
помощи molecule;
- Создать необходимые tasks, handlers;
- Определить все необходимые переменные в defaults и vars;
- Создать готовый тестовый playbook в tests, заполнить файлы molecule для проведения тестирования;
- Заполнить meta всю информацию о роли, наиболее полно описать её в README.md.

### 6Структура директорий   00:16:59
После инициализации новой роли мы получаем следующие
директории и файлы:
- стандартный набор директорий и файлов для role;
- `molecule/<name_scenario>` – набор **scenarios** для тестирования.
Внутри любого **scenario** находятся следующие файлы:
- `molecule.yml` – основной файл для molecule;
- `converge.yml` – playbook, который molecule будет использовать для запуска тестов;
- `verify.yml` – дополнительные тесты после исполнения role.


- 00:17:20 - Команда запуска по созданию новой роли молекулой `molecule init role new_role`. Появится новая директория `new_role`
- 00:18:20 - Помимо всего появилась директория `/molecule/default`. `default` - это имя сценария тестирования.
- 00:18:50 - описание файлов в сценарии тестирования
- 00:19:20 -`molecule.yml`

  ```yml
  ---
   dependency:
     name: galaxy
   driver: 
     name: docker #по умолчанию delegated
   platforms:     # перечисление ВМ, которые будут создаваться этим драйвером
     name:
       - el-instane
       - k-instane
       - applications-instane  # напоминает Docker-Compuse yml manifest
   provisioner:   # кто запускает против тех платформ, которые описаны
     name: ansible
     # сюда же можно разместить group_vars, host_vars
       inventory:
         group_vars:
           group_name:
             name_variables
   verifier:
     ansible
   ```
  
  ```yml
  
  ```
  
  
- 00:20:00 - Внутри директории `molecule` можно создать `requrements.yml`, на основани икоторого все будет скачаны нужные роли
- 00:22:20 - про `verifier`. Это для того, чтобы после прогонки всего тестирования проверить, что действительно, те изменения, которые мы хотели получить на ВМ мы получили. Ранее это была `testinfra`

На самом деле мы пишем некоторый плейбук в файл `verify.yml`
  ```yml
  ---
  - name: Verify
    hosts: all
    gathet_facts: false
    tasks:
    - name: Example assertion
      assert: 
        thet: true
  
  ```
- 00:23:20 - `verify.yml` отрабатывается в самом конце отработки `molecule.yml`. Молекуле все равно что запускать. Хоть здесь еще одну роль запиши и она ее запустит. Но это наша возможность прверить, что все хорошо прошло.
- 00:24:10 -`create.yml` - для создания ВМ, `destroy.yml` - для удаления ВМ
- 00:24:30 - `create.yml` и `destroy.yml` появляются только тогда, когда используется либо OpenStack дрейвер,либо Delegate драйвер
- 00:24:40 - `create.yml` когда в Docker работает, таб плейбук гонять не надо, а когда ВМ в облаках, то это плейбук - это несколько тасок, которые создают то самое динамическое инвентори.
- 00:26:00 - про `destroy.yml`
- 00:26:20 -`converge.yml`- это просто плейбук, чтобы запустить нашу роль

```yml
---
- name: Converge
  hosts: all
  become: true  # это не самая хорошая практика
  tasks:
  - name: "Include new role"
    inclede_role:
    name:
      new_role
```
- 00:26:50 - Зайти в директорию с ролью и запустить команду `molecule init scenario <name_scenery docker>  --driver-name docker`



- 00:29:15 - установка пакета `molecule_docker` `pip3 install "molecule_docker<0.3"`
- запуск команды `molecule init scenario <name_scenery docker>  --driver-name docker`
- что-то там не понравилось и решили запускать на openstack
- запуск команды `molecule init scenario open --driver openstack`
- 00:29:05 - появилась новая директория `open`. Это наш новый отдельный сценарий
- 00:29:35 - описание файла сценария `molecule.yml`
- 00:29:57 - описание файла сценария `create.yml`. Его мы почти никогда не меняем
- 00:31:00 - описание файла сценария `destroy.yml`
- 00:31:05 - описание файла сценария `prepare.yml` Для подготовки хоста, чтобы на нем работала роль или молекула. Он сначала создал ВМ, потом запускает шаг prepare и проверяет установлен ли в ОС python. Если нет, то он устанавливается. Содержимое можно переписать на свое.
- 00:32:00 - о сценариях для  Докера

  ```yml
  ---
   dependency:
     name: galaxy
   driver: 
     name: docker #по умолчанию delegated
   platforms:     # перечисление ВМ, которые будут создаваться этим драйвером
   - name: Centos7
     image: docker.io/.../centos:7
     pre_build_image: true  # значит, что образ готов, бери его и используй с именем Centos7
                            # если бы тут было false,то сожно в эту же директорию положить Dockerfile. Molecole автоматически этот образ бы собирала
                            # и использовала
                            
   - name: Ubuntu
      image: docker.io/.../ubuntu:latest
      pre_build_image: true
      
   provisioner:   # кто запускает против тех платформ, которые описаны
     name: ansible
     # сюда же можно разместить group_vars, host_vars
       inventory:
         group_vars:
           group_name:
             name_variables
   verifier:
     ansible
     
   lint:                # сюда можно добавить линтер. Статический анализ
   
   scenario:            # сюда можно добавить какие scenario будут запускаться. Определение последовательности выполнения шагов внутри сценария
     - default
     - <name_scenery>
   ```
- 00:32:30 - о том, как включить работу молекулы с файлом Dockerfile. `create` `destroy` тут никакого нет, потому что п офакту `create`  -это `docker run -d sleep 6000000`, а `destroy` - `docker ps` и все, до свидания
- 00:33:27 - о папке `/alternative` все тоже самое, только для `podman`, а это тот же Docker, только сбоку.
- 00:33:45 - подытог. 

### 7Структура molecule.yml   00:34:23
Внутри файла находятся следующие директивы:
- dependency – перечисление зависимостей роли. Чем скачиваются, например **galaxy**;  
- driver – указание параметров выбранного driver, напримерб **docker;
- platform – перечисление хостов для выбранного driver;
- provisioner – указание поставщика для molecule, например,**ansible**; там же можно указать **group_vars**
- veriﬁer – выбор framework для проведения проверок.
Туда же можно добавить:
- lint – конфигурирование linter для тестирования;
- scenario – перечисление сценариев тестирования.

Об этом смотреть на  00:32:00 - о сценариях для  Докера
  ```yml
  ---
   dependency:
     name: galaxy
   driver: 
     name: docker #по умолчанию delegated
   platforms:     # перечисление ВМ, которые будут создаваться этим драйвером
   - name: Centos7
     image: docker.io/.../centos:7
     pre_build_image: true  # значит, что образ готов, бери его и используй с именем Centos7
                            # если бы тут было false,то сожно в эту же директорию положить Dockerfile. Molecole автоматически этот образ бы собирала
                            # и использовала
                            
   - name: Ubuntu
      image: docker.io/.../ubuntu:latest
      pre_build_image: true
      
   provisioner:   # кто запускает против тех платформ, которые описаны
     name: ansible
     # сюда же можно разместить group_vars, host_vars
       inventory:
         group_vars:
           group_name:
             name_variables
   verifier:
     ansible
     
   lint:                # сюда можно добавить линтер. Статический анализ
   
   scenario:            # сюда можно добавить какие scenario будут запускаться. Определение последовательности выполнения шагов внутри сценария
     - default
     - <name_scenery>
   ```


### 8Как правильно тестировать Role?   00:35:04
В данном виде тестирование role упрощается, так как нужно:
- Подготовить тестовое окружение;
- Запустить сценарий проверки через `molecule test`;
- Исправить ошибки на каждом из этих этапов и повторять весь
сценарий, пока не будет получен положительный результат.

### 9Как правильно тестировать Role?   00:35:50
Тестирование условно можно разделить на три вида:
- Использование полного сценария тестирования;
- Использование собственных сценариев тестирования;
- Использование отдельных частей сценария самостоятельно.

### 10Как правильно тестировать Role?   00:36:00
molecule test запускает полный сценарий тестирования role.
Полный сценарий включает в себя:
- запуск команды `molecile test`

Затем молекула пытается выполнить:
- lint – прогон линтеров;
- destroy – удаление старых инстансов с прошлого запуска;
- dependency – производит установку ansible-зависимостей, если есть;
- syntax – проверка синтаксиса с помощью `ansible-playbook --syntax-check`;
- create – создание инстансов для тестирования;
- prepare – подготовка инстансов, если это необходимо.

### 11Как правильно тестировать Role?        00:37:30
`molecule test` запускает полный сценарий тестирования role.
Полный сценарий включает в себя:
- converge – запуск тестируемого плейбука;
- idempotence – проверка на идемпотентность при помощи повторного запуска;
- side_effects – действия, которые не относятся к role, но необходимые для тестирования;
- 00:38:00 - написать отдельный файл `side_effects`

- verify – запуск тестов с помощью указанного фреймворка тестирования;
- cleanup – очистка внешней инфраструктуры от результатов тестирования;
- destroy – уничтожение инстансов для тестирования.

### 12Как правильно тестировать Role?        00:40:35 и    00:42:30
- Каждую из указанных частей сценария можно вызвать
отдельно, но нужно держать в уме, что у каждой из них могут
быть зависимости.
- Для того чтобы понимать, что каждая из tasks будет запускать, в
случае отдельного вызова – необходимо пользоваться
конструкцией `molecule matrix <task_name>`.
- Перед тем, как уничтожать инстансы, к ним можно подключиться
и в ручном режиме проверить все изменения в системе.
- Оставить возможность подключения можно и с полным
сценарием тестирования, воспользовавшись параметром
`--destroy=never`.
-  00:40:40 - когда мы запускаем `vklecule converge`, то запускается он не сразу, а сначала запустятся те таски, от которых этот `converge` зависит.
-  00:40:40 - Для того чтобы понимать, что каждая из tasks будет запускать, в случае отдельного вызова – необходимо пользоваться 
конструкцией `molecule matrix <task_name>`.

- 00:43:10 - Пример: 
`molecule-matrix converge` -       выдаст список **scenery** с шагами в каждом из них.
`molecule-matrix converge -s open`  -выдаст только для отдельного сцеария **open** Ключ `-s` - значит **scenario**
`molecule-matrix converge` - не удаляет за собой инстансы. Он прогонит роль, и можно к этим ВМ подключиться и посмотреть чсто там. 
- 00:44:30 - Причем подключиться можно тоже через молекулу. `molecule login -s <scenery_name> --host <hostname>`
- 00:45:10 - `--destroy=never` - не удалять ВМ после тестирования. Оставить возможность подключения можно и с полным сценарием тестирования, воспользовавшись параметром `--destroy=never`

### 13Как правильно тестировать Role?     00:45:20
Очерёдность сценариев можно переопределить через
директиву `scenario`. 
Формат записи в `molecule.yml` будет выглядеть так:
Команда   `molecule matrix test -s open`
- 00:46:00 - пояснение по файлу    `new_role/molecule/open/molecule.yml`. Как задать очередность выполнения **scenery**
- 00:46:35 - для проверки запускаем `molecule matrix test -s open`
```yml
---
scenario:
<task>_sequence:
- list
- of
- tasks
```

```yml
---
#Example of redefined of test scenario
scenario:
test_sequence:
- create
- converge
- idempotence
- destroy
```

### 14Список основных команд molecule     00:47:25
```ps
- molecule init role --driver-name <driver> <rolename>
```
```ps
- molecule init scenario --driver-name <driver> <scenarioname>
```
```ps
- molecule test
```ps
```
- molecule test --destroy=never
```
```ps
- molecule matrix <taskname>
```
```ps
- molecule matrix -s <scenarioname> <taskname>
```
```ps
- molecule <taskname>
```
- 00:48:00 - показ эксклюзива. Работа молекулы с облаками. Описание файла сценария `default/molecule.yml` для того, чтобы два сервера Вектор могли друг другу передавать данные

```yml
---
dependency:
  name: galaxy
lint: |           # здесь прописан bash-скрипт, который построчно вызывает ansible-lint против всех файлов, а потом yaml-lint
  ansible-lint .
  yaml-lint .
driver:
  name: openstack
platforms: 
- name: ${USER}--${BUILD_NUMBER:-locaL}-molecule-vector-role-centos7-outcomer
        # такое имя нужно для того, чтобы CI, когда эта штука запускается на TeamCity чтобы она могла работать в параллель. 
        # Т.е. создается уникальное и индивидуальное имя ВМ, где:
        # ${USER} - имя пользователя в ОС
        # ${BUILD_NUMBER} - номер сборки в TeamCity. Если его нет, то пишется locaL
        # Когда будет запускаться ВМ, то будет создаваться она с именем на основании шаблона


  image: centos-7-x86_64
  flavor: 1.2.60
  network: external
  ssh_user: ${MOLECULE_OPENSTACK_SSH_USER:-cloud-user}
          # ${MOLECULE_OPENSTACK_SSH_USER} - имя пользователя. Если его нет, то пишется -cloud-user
          # Когда будет запускаться ВМ, то будет запускаться она от имени на основании шаблона
  
  groups:         # ansible группа переменных
    - vector_inner
- name: ${USER}--${BUILD_NUMBER:-locaL}-molecule-vector-role-centos7-incomer
  image: centos-7-x86_64
  flavor: 1.2.60    # 1 - кол-во CPU, 2 - размер оперативки 2Gb, 60 - HDD 60Gb
  network: external
  ssh_user: ${MOLECULE_OPENSTACK_SSH_USER:-cloud-user}
  groups:
    - vector_outer
    
  provisioner:
    name: ansible
    inventory:
      group_vars:
      host_vars:
        vector_inner:
          vector config:
            sources:
              local:
                type: socket
                address: 127.0.0.1:6767
                max_lenght: 102400
                mode: "tcp"
            transforms:
              add_hostname:
                type: add_fields
                inputs: ["local"]
                overwrite: true
                fields:
                  host: "{{inventory_hostname}}"
            sinks: 
              to file:
                type: file
                inputs: "add_hostname"
                healthcheck: true
                path: "{{ vector_confnig_dir}}/local.log"
                encoding:
                  codec: ndjson
              to_clickhouse_vector:
                type: file
                inputs: "add_hostname"
                address: "{{ hostvars[groups['vector_outer'] [0]]['ansible_host']}}:6767
                healthcheck: 
                  enable: false
                buffer:
                  max_events: 500
                  type: memory
                  when_full: block
        vector_outer:
          vector_config:
          
    - 00:52:45 показано продолжение файла
                  
                  
                  
                  
        # To be Continue
                  
    
   verifier:
     name: ansible
  
  
```

- 00:52:50 - `create.yml` - не изменялся

- 00:52:56 - Описание файла `destroy.yml`
- 00:53:29 - Описание файла `verify.yml`
```yml
- name: Check local vector
  hosts: vector_inner
  gather_facts: false
  tasks:
  - name: Install nc
    become: true
    yum:
      name: nc
      state: present
   - name: Run debug message
     shell: set -o pipefail && echo "debug_mesage" | nc 127.0.0.1:6767 # здесь задаем передачу данных от одного Вектора к другому, и чтобы тот тоже смог их 
                                                                       # перебросить.
     register: qwe
     changed_when: false
   - name: Check local vector work correctly
     slurp:
       src: "{{ vector_config_dir}}/local.log"
       register: mounts
   - name: Set correct facts
       set_fact:
         debug_msg: "{{ monts['content'] | b64decode }}"
           
       
       
       
  
```

- 00:55:27- запуск команды `molecule test` и пояснение что происходит
- 01:00:00 - тест запуска при сломанном чем-то. Пояснение про то, как можно в Докер-контейнере прикрутить systemd с помощью Сигруп.
- 01:02:56 - как прогнать тест, но не уничтожить ВМ. Команда `molecule converge`
- 01:05:20 - итог прогонки `molecule converge`
- 01:05:30 - посмотреть что там на ВМ делается. Команда `molecule login --host <hostname> `. И дальше можно тестировать.
- 01:08:35 - как сделать коммит.
- 01:09:00 - об использовании `hint` в виде файла `pre-commt-config.yml`. Реклмендация сайта ]pre-commit.com](https://pre-commit.com). Выполняется прекомит чек
и есть уверенность на 90%, что мы линты пройдем.
- 01:11:45 - о том, что на ` control_node` бвыает разные версии Ансибл, а этот разный Ансибл может управляться разными Пайтонами. Чтобы этот зоопарк оттестировать можно испоьзовать Tox. Этот фреймворк связан не с Ансибл, а с Пайтон. tox – менеджер виртуальных окружений. Он создает ENV, в них накидывает пакеты, которые нам нужны. Причем разные версии пакетов. Он умеет их завпускать против разных Пайтонов, которые мы ему  скажем. Но они все должны быть установлены в моей системе. А в конце он запустит ту команду, которую мы укажем ему в аргументе. Например, запустить Пайтон.
- 01:13:10 - Тох нужен для подготовки разных окружений и запуска молекулы, которая запускает сценарии тестирования внутри разных Ансибл на `control_node`

### 15Tox     01:11:45
Данный фреймворк позволяет проводить тестирование любого
python кода, грубо говоря, tox – менеджер виртуальных окружений:
- Выбирать, какой версии python использовать (версии должны быть установлены в системе);
- Выбирать, какие дополнительные модули должны быть установлены;
- Тестировать разные версии модулей друг против друга (создавать матрицы тестирования).
Официальная документация [тут](https://tox.readthedocs.io/en/latest/)

- 01:14:15 - как пробрасывать ключи `ssh`. Пример конфигурации файла `create.yml`. Тестовый запуск и пояснения.

### 16Установка Tox     01:21:20
Так как он является стандартной библиотекой python кода (как и
ansible), то его установка происходит достаточно просто:
- pip3 install tox
- pip install tox

### 17Настройка Tox     01:22:27
В нашем случае, нам необходимо два файла для использования tox:
- tox.ini – основной файл настройки, содержит в себе
перечисление python и возможных модулей плюс описание их
перечисления друг против друга, а также указание команды,
которую необходимо выполнить для проведения тестирования
- test-requirements.txt – перечисление дополнительных модулей,
которые не должны иметь итерирования против разных версий
python.

### 18Запуск Tox      01:22:52
- tox – запуск на всех возможных окружениях,
- tox -l – показ всех возможных окружений,
- tox -r – принудительное пересоздание окружений,
- tox -e <env_names> – запуск на указанных окружениях

- 01:23:10 - разбор содержимого файла `tox.ini`
- 01:30:45 - про работу с образами Docker
- 01:31:04 - пример файла Dockerfile
- 01:32:04 - запуск `docker run -v` и сразу вход в терминал контейнера
- 01:34:15 - по командам запуска
- 01:42:55 - пояснение как запустить несколько ТОХ в параллель
- 01:47:10 - запуск команды `molecule test` и пояснение
- 01:50:50 - запуск команды `molecule converge` и пояснение
- 01:53:55 - запуск команды `molecule login` и пояснение
- 01:56:10 - пояснение по хендлеру и докер-контейнеру.на примере файла `main.yml`
- 01:56:25 - пояснение по ДЗ как сделать тест, при котором все роли друг с другом взаимодействуют
- 01:58:53 - запуск команды `molecule destroy`
- 01:59:30 - пояснение о том, что молекулу можно использовать как эмулятор поведения терраформ


### 19Итоги

### 20Итоги     01:58:40
Сегодня мы узнали, что:
● существует удобный framework для тестирования – molecule;
● molecule позволяет проверить работоспособность роли против
разного окружения на managed node;
● второй framework для тестирования – tox;
● tox позволяет проверить работоспособность роли против
разного окружения на control node.

### Практическая часть лекции

### 21Домашнее задание      02:03:50
Давайте посмотрим ваше домашнее задание.
● Вопросы по домашней работе задавайте в чате мессенджера
Slack.
● Задачи можно сдавать по частям.
● Зачёт по домашней работе проставляется после того, как приняты
все задачи.

- 02:03:50 - по предврительной подготовке. Нужно создать Докер-образ для дальнейшего тестирования ТОХ
- 02:04:25 - пояснение как делать. Зайти в роли и запускать команду `molecule init scenario ` и указать с каким драйвером этот сценарий сделать. Ожидаемый результат - это все сценарии 
- 02:04:55 - сначала скачать роль `elasticsearch` и прогнать по ней тест. Для этого надо чтобы был установлен Докер, молекула и докер-образ. Смотрим вывод команд
- 02:05:13 - по задача №2
- 02:05:37 - по задаче №3
- 02:05:58 - по задаче №4
- 02:06:33 - по задаче №5
- 02:06:40 - по задаче №6
- 02:06:50 - по ТОХ задача №1
- 02:07:17 - по ТОХ задача №2
- 02:08:00 - по ТОХ задача №3. Файл `tox.ini` можно взять из тот, что приложен к ДЗ
- 02:08:05 - по ТОХ задача №4. `molecule test -s <name_scenery>`
- 02:08:55 - по ТОХ задача №5
- 02:08:33 - по ТОХ задача №6
- 02:12:00 - пояснения по `assert` с примером файла `molecule/default/verify.yml` где показана проверка того, что в фраза `debag message` пристутствует в фале `debag_msg.message`



### 22Задавайте вопросы и
пишите отзыв о лекции!
Алексей Метляков
Алексей Метляков
