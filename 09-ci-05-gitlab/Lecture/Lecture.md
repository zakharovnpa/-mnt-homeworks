GitLab
1
Алексей
Метляков
Алексей Метляков
DevOps Engineer
OpenWay
Алексей Метляков
2
План занятия
1. GitLab
2. Own Issues
3. Own Wiki
4. Own Repository
5. Own CI\CD
6. Own Packages
7. Итоги
8. Домашнее задание
3
GitLab
4
Что такое GitLab?
GitLab – ППО для полного контроля над производственным циклом
ПО. Активно использует Ruby и Redis, есть возможность
использовать SaaS (Software as a Service), так и установить
на своей инфраструктуре.
● Существует в следующих исполнениях:
○ Community Edition (CE) – бесплатная версия c
функционалом, не требующим проприетарного кода;
○ Enterprise Edition (EE) – полноценная версия GitLab
Полное описание различий CE и EE на сайте.
● Использует YAML для описание пайплайнов.
5
Что такое GitLab?
Некоторые основные возможности системы:
● хранение репозитория (git),
● отслеживание задач (issue tracking),
● хранение страниц описания продукта (wiki, static site),
● хранение артефактов (repository, registry),
● создание CI\CD конвейера.
6
Архитектура GitLab
NGINX
GitLab
Pages
Redis
80,443
TCP
Gitaly
GitLab
Workhorse
Redis
PostgreSQL
Sidekiq
Puma
22 TCP GitLab Shell
Архитектура GitLab
route
request
publish
static site
cache
storage
browser
git storage
service
reverse
proxy
cache
storage
meta and
user data
storage
job
processor
Web
Server
git session
handler git
Полное описание архитектуры есть на [официальном сайте](https://docs.gitlab.com/ee/development/architecture.html)


## Компоненты Gitlab
9

### Own Issues    - 00:27:45, - 00:30:50
Issue Tracking – отдельная компонента GitLab, позволяющая
создавать issue или incident для конкретного проекта.
Позволяет:
- выставлять label,
- организовать service desk,
- группировать через milestone,
- связывать issue между собой.


- 00:29:18 - создание нового проекта (один проект - один репозиторий)
- 00:30:30 - Create Project
- 00:30:45 - заходим в Issues
- 00:32:40 - создание новой Issue
- 00:33:30 - Milestone. Это аналоги эпиков в Jire, когда мы пытаемся достичь одной общей цели. И когда мы хотим этой целью связать несколько Issue
- 00:33:46 - создаем новый Milestone
- 00:34:26 - продолжаем создавать новый Issue
- 00:35:17 - заходим внутрь Issue
- 00:35:32 - вкнопка создания Merge Request. Будет создаваться отдельная ветка с названием `1-example` и от какой ветки создавать (main). Тогда он сделвет MergeRequest
 внутрь ветки main
- 00:36:15 - или создавать только саму ветку
- 00:36:25 - показаны Boards для отслежтвания выполнения задач и возможности
- 00:36:45 - показан Service Desk - для создания доски с моими тикетами
- 00:37:20 - как отправить e-mail в Issue для создания тикета
- 00:37:35 - Issue --> List. Видим наше письмо. Так огранизовано общение пользователей с разработчиками.
- 00:40:50 - workflow простой. Открыть задачу, создать ветку, закрыть задачу
- 00:41:40 - создание новой ветки. Нажать кнопку `Create branch`, поставить глочку `Create branch` и снова нажать внизу кнопку `Create branch`.
- 00:41:50 - при создании новой ветки автоматом переключаемся в это репозиторий
- 00:42:43 - в целом Gitlab Wlow для работы с репозиториями он очень маленький. Ветки в нем короткоживущие, надо очень часто делать Merge в мастер, одна ветка на одну фичу. 
Все инструменты легковесные для того чтобы все быстро делать


10
### Own Wiki    - 00:43:17
Wiki – компонент, позволяющий оформить странички с
произвольным содержанием и привязать их к проекту, аналог
Confluence от Atlassian.

- 00:43:29 - создание новой страницы
- 00:44:05 - можно делать коммиты для сохранения версий страницы
- 00:45:15 - нет возможности вставит диаграммы типа drow.io, плагинов накрутить сверху не получиться. Только стандартный Markdown. Для маленьких проектов это хорошо, для больших проектов - это плохо.


11
### Own Repository    - 00:46:01
Gitaly – gRPC (Remote Procedure Call) система, которая
обрабатывает вызовы (TCP / Socket) процедур обработки
информации и транслирует их на файловую систему напрямую
(local / NFS) или через gRPC (TCP / Socket).
Также GitLab имеет собственную встроенную IDE для работы со
всеми файлами репозитория.

- 00:49:15 - с помощью Gitaly процесов можно делать балансировку за счет разнесения репозитриев на дополнительные машины.
- 00:50:10 - для пользователей встроено IDE
- 00:50:20 - показано как зайти
- 00:50:55 - кнопка `Open in Web IDE`
- 00:51:20 - создание нового файла. Работа в IDE.
- 00:52:50 - создание коммита. Можно полноценно работать с репозитрием, не копируя его себе на локальную машину.
- 00:55:15 - создать себе веб-терминал для просмотра как происходят сборки.
- 00:55:48 - возвращение обратно в проект. Нажать слева сверху на имя репозитория




12
### Own CI\CD     - 00:56:06
GitLab CI\CD – компонента, позволяющая строить CI, CDL и CDP
процессы над конкретным репозиторием.
Некоторые особенности системы:
- пайплайн пишется на YAML-синтаксисе;
- пайплайн хранится в корне репозитории в файле `.gitlab-ci.yml`;
- есть возможность использовать AutoDevOps;
- есть отдельные возможности миграции с Jenkins и CircleCI;
- позволяет использовать ChatOps.

- 00:56:55 - про возможности ChatOps. Можно, например, в Слаке воткнут бота и ему дать команду на сборку, а он берет и запускает сборку





13
### Own CI\CD     - 00:57:47
Pipeline описывается в файле `.gitlab-ci.yml` и имеет следующую
структуру:
14
```
stages:     # Перечисление шагов сборки в том порядке, в котором они буду происходить.
 - build
 - test
 - deploy
 
 
image: alpine     # образ для создания агента. Здесь можно указать любой свой образ в Docker Hub или где угодно, главное, чтобы он был доступен гитлабу
                  # и его можн было запустить в виде контейнера или пода.

# перечисление самих шагов:
our_builder:      # имя шага из стадии build. Можно назвать как угодно
 stage: build     # Стадия сборки - build
 script:          # Что мы будем выполнять. Это steps. Несколько скриптов можно выполнять через list?
 - echo “Some build everything”
 
our_tester:
 stage: test
 script:          # Steps
 - echo “We can test everything”
 
our_deployer:
 stage: deploy
 script:          # Steps
 - echo “We can deploy sometimes”
 - echo “And some more action too”
```

- 00:58:10 - при запуске сборки поднимаются контейнеры (кберы и поды) на основе образа, обознасченного в строке `image: alpine`
- 00:58:30 - перечисление шагов сборки


 
### Own CI\CD     - 01:01:00
При этом можно использовать триггеры разных видов, для разных
конвейерных лент:
15
* пример `.gitlb-ci.yaml` в корне репозитория
```
stages:
- triggers
triggers_a:
 stage: triggers
 trigger:
 include: a/.gitlab-ci.yml
rules:
 - changes:
 - a/*
triggers_b:
 stage: triggers
 trigger:
 include: b/.gitlab-ci.yml
 rules:
 - changes:
 - b/*
 ```
 - 01:01:15 - триггеры позволяют запускать сборки по событиям
 - 01:01:30 - триггер А запускает Piplene, который находится в директории `a` в файле `.gitlb-ci.yaml` в том случае, если в директории `a` хоть что-то поменялось.
 - 01:02:00 - про монорепозитории. Когда репозитрий один, а в нем хранятся сабдиректори. Можно указывать конкретные файлы для отслеживания изменений в них
 

### Own CI\CD       - 01:03:47
Структура файлов с конвейерами ниже:
* Пример файла `a/.gitlab-ci.yml` 
16
```
stages:
- build
 - test
 - deploy
image: alpine
our_builder_a:
 stage: build
 script:
 - echo “Some build everything”
our_tester_a:
 stage: test
 needs: [our_builder_a]       # указываем, что стадию test запускать после выполнения стадии our_builder_a
 script:
 - echo “We can test everything”
our_deployer_a:
 stage: deploy
 needs: [our_tester_a]
 script:
 - echo “We can deploy sometimes”
 - echo “And some more action too”
 
 ```
 * Пример файла `b/.gitlab-ci.yml`
 ```
stages:
- build
 - test
 - deploy
image: alpine
our_builder_b:
 stage: build
 script:
 - echo “Some build everything else”
our_tester_b:
 stage: test
 needs: [our_builder_b]
 script:
 - echo “We can test everything else”
our_deployer_a:
 stage: deploy
 needs: [our_tester_b]
 script:
 - echo “We deploy sometimes else”
 - echo “And some else action too”
 ```
 - 00:06:30 - про использование многострочных правил для контроля изменений в субдиректори
 
 
### Own CI\CD     - 01:07:20
Основные ключевые слова, необходимые при проектировании
конвейеров:
17
||||||
|-|-|-|-|-|
after_script |allow_failure |artifacts |before_script| coverage
dependencies |environment |except| extends| image
include |inherit |interruptible |needs |only
pages| parallel |release |resource_group |retry
rules |script |secrets |services| stage
tags |timeout |trigger| variables| when

* Полный перечень ключевых слов и их параметров доступен в
[официальной документации.](https://docs.gitlab.com/ce/ci/yaml/README.html)

- 01:09:00 - показан сайт с кейвордами

### Own Packages
Packages & Registries – компонента хранения артефактов сборки и
образов. Подсистема packages поддерживает хранение:
- Composer
- Conan
- Go
- Maven
- npm
- Nuget
- PyPI
- Generic Packages
Подсистема registries хранит набор docker-образов.
18

### Итоги
19

### Итоги    - 01:50:00
Сегодня мы узнали, что GitLab – полноценный комплексный продукт
управления вашим проектом, который:
- позволяет хранить исходный код;
- контролировать жизненный цикл;
- строить конвейер и управлять им;
- создавать странички с документацией;
- сохранять и использовать артефакты сборок;
- изменять файлы в репозитории, создавать новые, при помощи встроенной IDE;
- и всё это внутри единого web-интерфейса.
20

- 01:52:45 - о преимуществах GitLab
- 02:00:20 - про DevOps инженера. Надо уметь сторить процессы, и доносить их до людей

### Домашнее задание
Давайте посмотрим ваше домашнее задание.
- 00:27:55 - Регистрация на GitLab
- 01:11:40 - Мы будем собирать Docker контейнер. У нас есть файл `.py` и его надо вставить в Docker контейнер. А в этом контейнере потом запускается
этот самый файл `.py`
- 01:12:12 - описание файла `.py`. В этот раз мы посмотрим на Flask
 * Тут создается web-сервер http. Он умеет работать с API. 

### Описание      - 01:13:25
 * Этот код при запуске открывет сокеты API на прослушивание по порту 5290 (строки 14-15) и ждут когда к ним будут приходить веб-запросы по http
 * Если придет веб-запрос (строка 11) на контекст '/get_info', то тогда в ответ сервер будет возвращать дикт (строка 10) и больше ничего
 * Есть класс info (строка 08). Он связан с Resource
 * Есть тип самой строки запроса (строка 10)
 * По гет запросу (строка 09) необходимо возвращать

```py
00 from flask import Flask, request
01 from flask_restful import Resource, Api
02 from json import dumps                # Это лишнее, можно удалить
03 from flask_jsonpify import jsonify    # Это лишнее, можно удалить
04
05 app = Flask(__name__)
06 api = Api(app)
07
08 class Info(Resource):
09    def get(self):
10        return {'version': 3, 'method': 'GET', 'message': 'Already started'} # Fetches first column that is Employee ID
11
12 api.add_resource(Info, '/get_info') # Route_1
13
14 if __name__ == '__main__':
15      app.run(host='0.0.0.0', port='5290')

```
- 01:14:50 - установка flask flask_restfull
- 01:15:20 - запуск файла `api.py` и, соответсвенно, сервера
- 01:15:40 - проверка работы сервера `curl localhost:5290`- неуспешная. Ответ - ошибка 404
- 01:16:10 - запрос с контекстом `curl localhost:5290/get_info`. В ответ возвращается JSON (строка кода 10) `{'version': 3, 'method': 'GET', 'message': 'Already started'}`
- 01:17:10 - про то как можно создат ьсвой ресурс, например для запуска `run_pipline`. Если вызвали `run_pipline`, то тогда наш код (строка 09-10) должна определить какой запустить pipeline в Jankins.
Здесь будет проставлена хардкорная ссылка на то, куда надо пойти Jankins для запуска джобы
- 01:17:55 - выключение веб-сервера. Ctrl-C

- 01:18:00 - вставляем наш файл `.py`в репозиторий гитлаб
- 01:18:40 - создание файла `.gitlb-cy.yaml` на основе шаблона. Например для работы с Docker контейнерами
- 01:24:54 - создали Dockerfile
- 01:25:27 - описание созданных файлов `.gitlb-cy.yaml`, `api.py` и Dockerfile
- 01:26:10 - коммитим в ветку main


- 01:26:20 - про CI/CD (знак ракеты)
- 01:29:00 - про переменные для логина и пароля для входа на Registry
- 01:29:30 - про Registry
- 01:31:30 - скачивание образа из Registry гитлаба
- 01:31:50 - запуск контейнера и проверка что все работает как положено.
- 01:34:10 - про CI/CD/. Можно смотреть какие запущены pipline и запускать их
- 01:34:20 - 
- 01:34:40 - про lint для проверки кода
- 01:35:17 - про Edito. Он позволяет посмотреть на наш код, есть линт для проверки кода
- 01:37:11 - schedulle for pipline
- 01:37:40 - Testkeys

- 01:38:30 - Infrastucture Registry. Можно хранить модули, например Terraform
- 01:38:40 - Настройки проекта --> Runners. Здесь про запуск дополнительных раннеров. Про создание своих раннеров, 
- 01:39:15 - про то что можно подключить свой Kubernetis
- 01:39:20 - Specific Runner - конструктор раннеров для запуска на своей инфраструктуре, а все остальное будет гитлабовское
- 01:39:57 - интеграции. Например с Jenkins, TeamCity, Jira, Prometheus, Slack
- 01:40:25 - про настройку метрик для администрирования гитлаба
- 01:41:25 - про вкладку Deployment. Отвечает за релизы 
- 01:41:45 - про Kubernetis кластер. Можно подключить кластер, поднять на нем агентов и потом на агентах запускать раннеры
- 01:42:35 - показаны Pipline и Deploy. 
- 01:42:45 - создание второй стадии билда и запуск с показом логов. 
- 01:45:50 - для каждого стейджа запускается отдельный джоб. И каждый раз собирается тот контейнер, который просишь.

- 02:01:35 - по ДЗ
- 02:02:30 - про роль DevOps инженера. В п. 3 убрать завсимость `flask-jsonpify`. В п.7 попытаться собрать, если это не ветка main/
- 02:03:34 - про роль Product Owner. Надо создать таску внутренней гитлабовской штукой.
- 02:04:15 - про роль Developer. Здесь надо постараться максимально поиграться с автоматизациями. Там можно сразу создавать ветку и делать Merge Request из тикета сразу же, более того есть возможность в Merge Request указать чтобы он автоматически смержился, если сборка прошла успешно. Он автоматически смержится внутрь ветки main и при этом должен автоматически закрыться тикет. И даже удалит ветку, созданную для доработки кода. 
!!! Предупреждение: пока не делать автоматический мержд при успешной сборке.
- 02:05:50 - про роль Tester. П. 2 сделать вручную из своего Докер-реджистри. По аналогии с тем, ка делал Алексей.
- 02:06:25 - по Итогу. Должно быть три файла в репозитории: `python-api.py`, Dockerfile, `.gitlab-ci.yml`. Должны проходить успешные сборки, должен быть один закрытый тикет в соответствии с теми требованиями которые есть и должен быть один закрытый Merge Request, в Докер Реджистри должен лежать файл образа `python-api: latest`

- 02:07:00 - про необязательную часть. Доработать на наше усмотрение.



● Вопросы по домашней работе задавайте в чате мессенджера
Slack.
● Задачи можно сдавать по частям.
● Зачёт по домашней работе проставляется после того, как приняты
все задачи.
21
Задавайте вопросы и
пишите отзыв о лекции!
Алексей Метляков
Алексей Метляков
