# Ход выполнения Домашнего задания к занятию "10.01. Зачем и что нужно мониторить"

## Обязательные задания     - 01:17:00

1. Вас пригласили настроить мониторинг на проект. На онбординге вам рассказали, что проект представляет из себя 
платформу для вычислений с выдачей текстовых отчетов, которые сохраняются на диск. Взаимодействие с платформой 
осуществляется по протоколу http. Также вам отметили, что вычисления загружают ЦПУ. Какой минимальный набор метрик вы
выведите в мониторинг и почему?

Андрюнин: чем больше напишем метрик, тем лучше

**Ответ:**

Вероятно, что на платформе существует низкопроизводительный компонент, который создает "бутылочное горлышко" при вычислениях.
Это может быть недостаточный размер RAM (при этом будет идти активный свопинг), слабый CPU (при этом его загрузка будет близка к 100%).
Также причина может быть в образовании большого количества текстовых файлов (отчетов) и образования ошибок при передаче их по сети.
Менее вероятно, что недостаточно свободного места на HDD (при этом ОС может приостанавливать процессы, участвующме в вычислениях). Поэтому для определения
причины высокой загрузки CPU необходимо включить в мониторинг следующие метрики:

* Згрузка RAM
* Згрузка CPU
* Размер SWAP
* Температура HDD
* Свободное место на HDD
* кол-во операций чтения HDD
* кол-во операций записи HDD
* Скорость записи на HDD
* Скорость чтения на HDD
* кол-во свободных inodes
* кол-во созданных файлов нужного формата
* кол-во удаленных файлов нужного формата
* Минимальный размер создаваемого файла нужного формата
* Максимальный размер создаваемого файла нужного формата
* Кол-во файлов размером менее 10кб
* Кол-во установленных сессий TCP в состоянии `TIME-WAIT`, `ESTABLISHED`, `SYN-SENT`, `CLOSING` 



Не актуально:
* Какой % от кол-ва всех файлов составляет кол-во файлов среднего размера
* Градация кол-ва создаваемых текстовых файлов по размерам. Разница между мин. и макс. размером. 

Допустим, мин. размер - 150 кб, макс. размер - 10Мб
  - 0 - 10%
  - 11 - 20%
  - 21 - 30%
  - 31 - 40%
  - 41 - 50%
  - 51 - 60%
  - 61 - 70%
  - 71 - 80%
  - 81 - 90%
  - 91 - 100%

Не актуально:
* OS - очередь на передачу данных
* Ошибки сети
 



2. Менеджер продукта, посмотрев на ваши метрики сказал, что ему непонятно что такое RAM/inodes/CPUla. Также он сказал, 
что хочет понимать, насколько мы выполняем свои обязанности перед клиентами и какое качество обслуживания. Что вы 
можете ему предложить?

Андрюнин: это про SLO, SLA, SLI
Почитать статью [Управление инцидентами SLA, SLO и SLI: в чем разница?](https://www.atlassian.com/ru/incident-management/kpis/sla-vs-slo-vs-sli)

**Ответ:**
Для контроля качества предоставляемых услуг существуют следующие параматры:

* Что такое SLA?
```
SLA (соглашение об уровне обслуживания) — это соглашение между поставщиком и клиентом об измеримых показателях, таких как время безотказной работы, время реагирования, а также мерах ответственности.

Эти соглашения обычно составляются новыми юридическими и бизнес-командами компании. В них включаются обещания, которые вы даете клиентам, а также последствия, которые повлечет за собой невыполнение этих обещаний. Как правило, последствия включают в себя штрафы, компенсации или продление лицензий.

Задача SLA
Как известно, SLA сложно измерить, представить в отчете и выполнить. Эти соглашения (обычно их пишут люди без детальных знаний о технологиях) часто содержат обещания, которые командам трудно измерить. Они не всегда соответствуют текущим и постоянно меняющимся бизнес-приоритетам и не учитывают всех тонкостей.

Например, соглашение SLA может содержать обещание, что команды решат проблемы с продуктом X в течение 24 часов. При этом в SLA не оговаривается, что произойдет, если клиенту потребуется 24 часа на отправку ответов или снимков экрана, необходимых команде для диагностики проблемы. Означает ли это, что 24 часа, отведенные команде, пропали из-за медлительности клиента? Или отсчет времени начинается после получения отклика от него? В SLA должны быть ответы на эти вопросы, но часто их нет. Поэтому многие менеджеры ИТ относятся к соглашениям неодобрительно.

По мнению многих экспертов, для решения этой задачи нужно прежде всего привлекать к созданию SLA технических специалистов. Чем более тесным будет сотрудничество команд ИТ и DevOps с юридическими и бизнес-командами при создании соглашений SLA, которые соответствуют реальным ситуациям, тем больше будут отражены в SLA реальные условия (например, задержка решения проблемы по вине клиента).

Кому нужны соглашения SLA?
SLA — это соглашение между поставщиком и клиентом, который оплачивает сервис. Компании, которые предоставляют бесплатные услуги, вряд ли нуждаются в SLA для своих пользователей.
```

* Что такое SLO?
```
SLO (цель уровня обслуживания) — это соглашение в рамках SLA о конкретном показателе, например о времени безотказной работы или времени реагирования. Таким образом, если соглашение SLA является формальным соглашением между вами и клиентом, то SLO — это отдельные обещания, которые вы даете клиенту. Соглашения SLO формируют ожидания клиентов и показывают командам ИТ и DevOps, каких целей они должны достичь и на какие показатели ориентироваться.

Задачи SLO
Соглашения SLO вызывают меньше неодобрения, чем SLA, но могут создать не меньше проблем, если будут расплывчатыми, излишне усложненными или не поддающимися измерению. По мнению инженеров, главная черта хороших соглашений SLO — простота и ясность. Претендовать на статус SLO могут только самые важные показатели. Цели должны быть изложены простым языком и, как и в случае SLA, должны всегда учитывать такие проблемы, как задержки на стороне клиента.

Кому нужны соглашения SLO?
Если соглашения SLA актуальны только для платных клиентов, соглашения SLO могут быть полезны как для платных, так и для бесплатных аккаунтов, а также для внутренних и внешних клиентов.

Внутренние системы, такие как CRM, репозитории клиентских данных и интранет, могут быть не менее важны, чем внешние системы. Соглашения SLO для этих внутренних систем — не только важное условие достижения бизнес-целей. Они позволяют внутренним командам достигать собственных целей, ориентированных на клиента.
```
* Что такое SLI?
```
Индикатор уровня обслуживания (SLI) измеряет соответствие цели уровня обслуживания (SLO). Например, если в SLA указано, что системы будут доступны 99,95 % времени, то в качестве SLO, вероятно, будет выбрано время безотказной работы 99,95 %, а в качестве SLI — фактическое измеренное время безотказной работы. Возможно, оно составит 99,96 %. Или 99,99 %. Чтобы удовлетворять требованиям SLA, индикатор SLI должен соответствовать обещаниям, зафиксированным в этом документе, или превосходить их.

Задачи SLI
Как и в случае SLO, задача состоит в том, чтобы индикаторы SLI были простыми, выбранные показатели можно было легко отслеживать, а работа ИТ-команд не усложнялась из-за отслеживания слишком большого числа показателей, которые на самом деле не важны для клиентов.
```

Необходимо уточнить у менеджера продукта какие действуют SLO, SLA. Затем получить из мониторинга SLI, сравнить его с SLO. Так мы сможем узнать насколько мы выполняем свои обязятельства перед клиентами и какое результирующее качество обслуживания. 

Можно предположить, что проект заключается в создании документов для бухгалтерской отчетности при проведении ежедневных операций продаж на нескольких площадках (филиалах) компании. В таком случае, параметрами качества обслуживания можно взять кол-во подготовленных документов (финансовых отчетов) за период времени. Т.е. производительность создания документов. Высокая нагрузка на CPU приводит к невозможности формировать отчеты, соответствено падает производительность.

Требования клиента по созданию отчетов:
- 500 шт./час для документов размером менее 500000 байт
- 200 шт./час для документов размером от 500001 байт до 1000000 байт
- 100 шт./час для документов размером от 1000001 байт до 5000000 байт 
- 50 шт./час для документов размером от 5000001 байт до 10000000 байт 
- 10 шт./час для документов размером от 10000001 байт до 15000000 байт
- Для файлов размером более 15000000 байт - параметра требование не предусмотрено по причине малой вероятости появления файлов такого размера.
- Итого: 860 шт./час

Технически мы гарантируем формирование такого количества отчетов в час:
- 490 шт./час для документов размером менее 500000 байт
- 195 шт./час для документов размером от 500001 байт до 1000000 байт
- 95 шт./час для документов размером от 1000001 байт до 5000000 байт 
- 48 шт./час для документов размером от 5000001 байт до 10000000 байт 
- 9 шт./час для документов размером от 10000001 байт до 15000000 байт
- Итого: 837 шт./час

В принятом с клиентом соглашении SLO = 97.325%. 

Переводим наше соглашение в SLA:
- SLA-500 = 490 шт./час для документов размером менее 500000 байт
- SLA-1000 = 195 шт./час для документов размером от 500001 байт до 1000000 байт
- SLA-5000 = 95 шт./час для документов размером от 1000001 байт до 5000000 байт 
- SLA-10000 = 48 шт./час для документов размером от 5000001 байт до 10000000 байт 
- SLA-15000 = 9 шт./час для документов размером от 10000001 байт до 15000000 байт
- Для файлов размером более 15000000 байт - параметра SLA не предусмотрен
- SLA-All: 837 шт./час


В систему мониторинга необходимо добавить метрики, высчитывающие кол-во созданных файлов в час:
* размером менее 500000 байт
* размером от 500001 байт до 1000000 байт
* размером от 1000001 байт до 5000000 байт 
* размером от 5000001 байт до 10000000 байт 
* размером от 10000001 байт до 15000000 байт
* размером более 15000000 байт - для статистики появления таких файлов и контроля за нагрузкой на наши вычислительные ресурсы.

Из систем мониторинга gолучаем SLI для каждого типа SLA. Затем высчитываем итоговый SLI по формуле:
```
(SLI_500 + SLI_1000 + SLI_5000 + SLI_10000 + SLI_15000) / SLI_All

```
Далее сравниваем с итоговый SLI с SLO и получаем ответ на вопрос менеджера о том, как мы выполняем свои обязанности перед клиентами и какое у нас качество обслуживания.

Что касается высокой загрузки CPU (в задаче №1), то нужно будет отследить соответствие нагрузки на CPU с нагрузками на другие метрики.

3. Вашей DevOps команде в этом году не выделили финансирование на построение системы сбора логов. Разработчики в свою 
очередь хотят видеть все ошибки, которые выдают их приложения. Какое решение вы можете предпринять в этой ситуации, 
чтобы разработчики получали ошибки приложения?

**Ответ:**

Андрюнин: придумайте ситуацию

Sentry
New Relic 
Data Dog - облачное решение, где хранятся логи
Syslog + Grep

Основные метрики для мониторинга в системах
сбора логов и ловли ошибок:
- Good events/All events
- Trafﬁc


Предположим, что ошибки приложений состоят из:
- ввод некорректных данных от клиентов
- синтаксические ошибки
- математические ошибки
- алгоритмические ошибки
- сессии TCP в состоянии 

Для сбора логов 

Для локально развертываемого решения можно использовать такие свободные системы мониторинга:
- [Sentry](https://sentry.io/welcome/)
- [New Relic](https://newrelic.com/platform/errors-inbox) Позволяет просматривать все ошибки с полным контекстом в одном месте. Ускоряет поиск первопричины благодаря полной информации об ошибке, включая stack traces.
- Syslog + Grep - решение, основанное на сборе всех логов с поиском ошибок приложений по заданным в скриптах шаблонам.

В случае облачного решения:
- [Data Dog](https://www.datadoghq.com/)



3. Вы, как опытный SRE, сделали мониторинг, куда вывели отображения выполнения SLA=99% по http кодам ответов. 
Вычисляете этот параметр по следующей формуле: summ_2xx_requests/summ_all_requests. Данный параметр не поднимается выше 
70%, но при этом в вашей системе нет кодов ответа 5xx и 4xx. Где у вас ошибка?

**Ответ:**

Т.к. в нашей системе считаются только те запросы, в число которых не входят ошибки клиента (4хх) и ошибки сервера (5хх),
то, в дополнение к этому, в представленной формуле недостает ошибок перенаправления (3хх).
Для корректного вычисления параметра SLI необходимо производить его вычисление по следующей формуле:

```
SLI = (сумма_запрсов_2xx + сумма_запрсов_3xx)/(сумма_всех_запрсов_)
```

Пример SLO:
В 99% случаев мы должны отдавать http коды отличный от 4xx/5xx. 1%
выделяется на техническое обслуживание.
Расчет SLI может выглядеть таким образом:
SLI = (summ_2xx_requests + summ_3xx_requests)/(summ_all_requests)


Ниже представлен обзорный список всех описанных в данной статье кодов ответа:


Диаграмма принятия веб-сервером решений на основе заголовков



Статистика по кодам ответа, сгенерированная анализатором логов Webalizer

* 1xx: Informational (информационные):
```
100 Continue («продолжай»)[2][3];
101 Switching Protocols («переключение протоколов»)[2][3];
102 Processing («идёт обработка»);
103 Early Hints («ранняя метаинформация»);
```
* 2xx: Success (успешно):
```
200 OK («хорошо»)[2][3];
201 Created («создано»)[2][3][4];
202 Accepted («принято»)[2][3];
203 Non-Authoritative Information («информация не авторитетна»)[2][3];
204 No Content («нет содержимого»)[2][3];
205 Reset Content («сбросить содержимое»)[2][3];
206 Partial Content («частичное содержимое»)[2][3];
207 Multi-Status («многостатусный»)[5];
208 Already Reported («уже сообщалось»)[6];
226 IM Used («использовано IM»).

```
* 3xx: Redirection (перенаправление):
```
300 Multiple Choices («множество выборов»)[2][7];
301 Moved Permanently («перемещено навсегда»)[2][7];
302 Moved Temporarily («перемещено временно»)[2][7], 302 Found («найдено»)[7];;
303 See Other («смотреть другое»)[2][7];
304 Not Modified («не изменялось»)[2][7];
305 Use Proxy («использовать прокси»)[2][7];
306 — зарезервировано (код использовался только в ранних спецификациях)[7];
307 Temporary Redirect («временное перенаправление»)[7];
308 Permanent Redirect («постоянное перенаправление»)[8].
```
* 4xx: Client Error (ошибка клиента):
```
400 Bad Request («неправильный, некорректный запрос»)[2][3][4];
401 Unauthorized («не авторизован (не представился)»)[2][3];
402 Payment Required («необходима оплата»)[2][3];
403 Forbidden («запрещено (не уполномочен)»)[2][3];
404 Not Found («не найдено»)[2][3];
405 Method Not Allowed («метод не поддерживается»)[2][3];
406 Not Acceptable («неприемлемо»)[2][3];
407 Proxy Authentication Required («необходима аутентификация прокси»)[2][3];
408 Request Timeout («истекло время ожидания»)[2][3];
409 Conflict («конфликт»)[2][3][4];
410 Gone («удалён»)[2][3];
411 Length Required («необходима длина»)[2][3];
412 Precondition Failed («условие ложно»)[2][3][9];
413 Payload Too Large («полезная нагрузка слишком велика»)[2][3];
414 URI Too Long («URI слишком длинный»)[2][3];
415 Unsupported Media Type («неподдерживаемый тип данных»)[2][3];
416 Range Not Satisfiable («диапазон не достижим»)[3];
417 Expectation Failed («ожидание не удалось»)[3];
418 I’m a teapot («я — чайник»);
419 Authentication Timeout (not in RFC 2616) («обычно ошибка проверки CSRF»);
421 Misdirected Request [10];
422 Unprocessable Entity («необрабатываемый экземпляр»);
423 Locked («заблокировано»);
424 Failed Dependency («невыполненная зависимость»);
425 Too Early («слишком рано»);
426 Upgrade Required («необходимо обновление»);
428 Precondition Required («необходимо предусловие»)[11];
429 Too Many Requests («слишком много запросов»)[11];
431 Request Header Fields Too Large («поля заголовка запроса слишком большие»)[11];
449 Retry With («повторить с»)[1];
451 Unavailable For Legal Reasons («недоступно по юридическим причинам»)[12].
499 Client Closed Request (клиент закрыл соединение);
```
* 5xx: Server Error (ошибка сервера):
```
500 Internal Server Error («внутренняя ошибка сервера»)[2][3];
501 Not Implemented («не реализовано»)[2][3];
502 Bad Gateway («плохой, ошибочный шлюз»)[2][3];
503 Service Unavailable («сервис недоступен»)[2][3];
504 Gateway Timeout («шлюз не отвечает»)[2][3];
505 HTTP Version Not Supported («версия HTTP не поддерживается»)[2][3];
506 Variant Also Negotiates («вариант тоже проводит согласование»)[13];
507 Insufficient Storage («переполнение хранилища»);
508 Loop Detected («обнаружено бесконечное перенаправление»)[14];
509 Bandwidth Limit Exceeded («исчерпана пропускная ширина канала»);
510 Not Extended («не расширено»);
511 Network Authentication Required («требуется сетевая аутентификация»)[11];
520 Unknown Error («неизвестная ошибка»)[15];
521 Web Server Is Down («веб-сервер не работает»)[15];
522 Connection Timed Out («соединение не отвечает»)[15];
523 Origin Is Unreachable («источник недоступен»)[15];
524 A Timeout Occurred («время ожидания истекло»)[15];
525 SSL Handshake Failed («квитирование SSL не удалось»)[15];
526 Invalid SSL Certificate («недействительный сертификат SSL»)[15].
```

## Дополнительное задание (со звездочкой*) - необязательно к выполнению
Пояснения:
Написать на Python, 

Для того, чтобы увидеть как собирать кастомные метрики, можно curl запустить на Prometeus.

[Prometeus + PushGateway + curl](https://prometheus.io/docs/practices/pushing/) 
[Пример](https://github.com/prometheus/pushgateway#command-line)

Самый простой способ как можно собирать кастомные метрики: Grep лога Ngnix, потом отправлять на curl, потом curl пушить PushGateway

или Zabbix Agent

или создать грепалку


Вы устроились на работу в стартап. На данный момент у вас нет возможности развернуть полноценную систему 
мониторинга, и вы решили самостоятельно написать простой python3-скрипт для сбора основных метрик сервера. Вы, как 
опытный системный-администратор, знаете, что системная информация сервера лежит в директории `/proc`. 
Также, вы знаете, что в системе Linux есть  планировщик задач cron, который может запускать задачи по расписанию.

Суммировав все, вы спроектировали приложение, которое:
- является python3 скриптом
- собирает метрики из папки `/proc`
- складывает метрики в файл 'YY-MM-DD-awesome-monitoring.log' в директорию /var/log 
(YY - год, MM - месяц, DD - день)
- каждый сбор метрик складывается в виде json-строки, в виде:
  + timestamp (временная метка, int, unixtimestamp)
  + metric_1 (метрика 1)
  + metric_2 (метрика 2)
  
     ...
     
  + metric_N (метрика N)
  
- сбор метрик происходит каждую 1 минуту по cron-расписанию

Для успешного выполнения задания нужно привести:

а) работающий код python3-скрипта, или грепалка

б) конфигурацию cron-расписания,

в) пример верно сформированного 'YY-MM-DD-awesome-monitoring.log', имеющий не менее 5 записей,

P.S.: количество собираемых метрик должно быть не менее 4-х.
P.P.S.: по желанию можно себя не ограничивать только сбором метрик из `/proc`.

**Ответ:**

[ДЗ на Python](https://github.com/zakharovnpa/01-devops-admin-homeworks/tree/main/04-script-02-py)

Создаем скрипт на Python

* Разработка скрипта для сбора метрик из директории логов ОС Ubuntu 20.04
```py
#!/usr/bin/env python3

# Скрипт проверки измененных файлов в локальной директории

# Импортируем модуль
import os
    
bashCommand = ["cd ~/netology-project/virt-homeworks-1", "git status"]	# команды, выполняемые в целевой директории
result_os = os.popen(' && '.join(bashCommand)).read()			# чтение

for result in result_os.split('\n'):		# выполнить разделение
    if result.find('изменено') != -1:		# условие, если результаты вывода команд соответствуют знчению поиска
    
#is_change = False	#удалили неработающую переменную

        prepare_result = result.replace('\tизменено:   ', '')	# перезаписать с добавлением знаков
        prepare_result = result.replace('\tизменено:', '/root/netology-project/virt-homeworks-1/')  #внесли путь до директории
        prepare_result = prepare_result.replace(' ', '')	#удаляем лишние пробелы
        print(prepare_result)					# вывести результат на экран
	
# break		#удалили останавливающую цикл команду

# The END

```



```py
#!/usr/bin/env python3

# Ранее это был скрипт для фиксации момента изменения IP адреса сервиса. Из него будем делать
# Скрипт для сбора метрик из директории логов ОС Ubuntu 20.04

# Импортируем модули
import socket 
import time
import datetime
import json
import yaml

fpath = "/root/scripts/Lesson-4.3/test3/" # путь к файлам

# Переменные с актуальными IP адресами сервисов на момент начала проверки
f = socket.gethostbyname('google.com')
g = socket.gethostbyname('drive.google.com')
h = socket.gethostbyname('mail.google.com')

# Массив для вывода результатов на экран
#server = ['     - google.com - '+f, '     - mail.google.com - '+h, '     - drive.google.com - '+g]

#Блок вывода результатов на экран
print('---       Внимание! Работает скрипт, определяющий актуальные IP адреса сервисов')
print('---       Результаты находятся здесь: /root/scripts/Lesson-4.3/test3/')
print('---       Для остановки скрипта и выхода нажмите Ctrl+C')
#print('---    Актуальные сейчас IP адреса сервисов:')
#print(server[0])
#print(server[1])
#print(server[2])
#print('Смены IP адресов:')
#print('---       Внимание! Работает скрипт, определяющий актуальные IP адреса сервисов')
#print('---       Результаты сохраняются в файлах')

# Массив для работы в цикле проверок
service = {'google.com':f, 'mail.google.com':h, 'drive.google.com':g}

# Переменные для работы цикла
i = 1              # Начальное значение переменной
waiting = 2        # интервал запуска тестов в секундах
init=0             # Значение для сброса счетчика итераций

#Блок цикла
while True:                    # бесконечное число проверок 
  for host in service:          # условие для каждого элемента (host )в массиве (service) 
    ip = socket.gethostbyname(host)     # получение ip адреса по имени хоста
    if ip != service[host]:    # сравнение полученного на предыдущем шаге ip адреса с адресом на начало проверки 
      if i==1 and init !=1:    # проверка условий для счетчиков

        # Строка, формирующая таблицу значений результатов проверок
        print(str(datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")) +' [ERROR] ' + str(host) +' IP mistmatch: '+service[host]+' '+ip)


# Блоки сборки  результатов проверок в файлы
# json
    with open(fpath+host+'.json', 'w') as jsf:
        json_data = json.dumps({host:ip})
        jsf.write(json_data)

# yaml
    with open(fpath+host+".yaml",'w') as ymf:
        yaml_data= yaml.dump([{host:ip}])
        ymf.write(yaml_data)

    service[host]=ip    # запись нового полученного ip адреса в массив

  time.sleep(waiting)     # таймер паузы в проверках

# The END




```

---

### Как оформить ДЗ?

Выполненное домашнее задание пришлите ссылкой на .md-файл в вашем репозитории.

---
